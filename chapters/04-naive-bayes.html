<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-99.9.9">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lectures on Machine Learning - 4&nbsp; The Naive Bayes classification method</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapters/05-1-gradient-descent.html" rel="next">
<link href="../chapters/03-probability.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">The Naive Bayes classification method</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Lectures on Machine Learning</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/01-linear-regression.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Linear Regression</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/02-pca.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Principal Component Analysis</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/03-probability.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Probability and Bayes Theorem</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/04-naive-bayes.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">The Naive Bayes classification method</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/05-1-gradient-descent.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Gradient Descent</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/05-logistic-regression.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Logistic Regression</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/06-svm.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Support Vector Machines</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/20-references.html" class="sidebar-item-text sidebar-link">References</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="toc-section-number">4.1</span>  Introduction</a></li>
  <li><a href="#an-example-dataset" id="toc-an-example-dataset" class="nav-link" data-scroll-target="#an-example-dataset"><span class="toc-section-number">4.2</span>  An example dataset</a></li>
  <li><a href="#bernoulli-tests" id="toc-bernoulli-tests" class="nav-link" data-scroll-target="#bernoulli-tests"><span class="toc-section-number">4.3</span>  Bernoulli tests</a></li>
  <li><a href="#feature-vectors" id="toc-feature-vectors" class="nav-link" data-scroll-target="#feature-vectors"><span class="toc-section-number">4.4</span>  Feature vectors</a></li>
  <li><a href="#likelihood" id="toc-likelihood" class="nav-link" data-scroll-target="#likelihood"><span class="toc-section-number">4.5</span>  Likelihood</a></li>
  <li><a href="#the-bag-of-words" id="toc-the-bag-of-words" class="nav-link" data-scroll-target="#the-bag-of-words"><span class="toc-section-number">4.6</span>  The Bag of Words</a></li>
  <li><a href="#other-applications" id="toc-other-applications" class="nav-link" data-scroll-target="#other-applications"><span class="toc-section-number">4.7</span>  Other applications</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
$$\newcommand{\df}[1]{\frac{\partial}{\partial #1}}$$
$$\newcommand{\R}{\mathbb{R}}$$

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">The Naive Bayes classification method</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="introduction" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">4.1</span> Introduction</h2>
<p>In our discussion of Bayes Theorem, we looked at a situation in which we had a population consisting of people infected with COVID-19 and people not infected, and we had a test that we could apply to determine which class an individual belonged to. Because our test was not 100 percent reliable, a positive test result didn’t guarantee that a person was infected, and we used Bayes Theorem to evaluate how to interpret the positive test result. More specifically, our information about the test performance gave us the the conditional probabilities of positive and negative test results given infection status – so for example we were given <span class="math inline">\(P(+|\mathrm{infected})\)</span>, the chance of getting a positive test assuming the person is infected – and we used Bayes Theorem to determine <span class="math inline">\(P(\mathrm{infected}|+)\)</span>, the chance that a person was infected given a positive test result.</p>
<p>The Naive Bayes classification method is a generalization of this idea. We have data that belongs to one of two classes, and based on the results of a series of tests, we wish to decide which class a particular data point belongs to. For one example, we are given a collection of product reviews from a website and we wish to classify those reviews as either “positive” or “negative.” This type of problem is called “sentiment analysis.” For another, related example, we have a collection of emails or text messages and we wish to label those that are likely “spam” emails. In both of these examples, the “test” that we will apply is to look for the appearance or absence of certain key words that make the text more or less likely to belong to a certain class. For example, we might find that a movie review that contains the word “great” is more likely to be positive than negative, while a review that contains the word “boring” is more likely to be negative.</p>
<p>The reason for the word “naive” in the name of this method is that we will derive our probabilities from empirical data, rather than from any deeper theory. For example, to find the probability that a negative movie review contains the word “boring”, we will look at a bunch of reviews that our experts have said are negative, and compute the proportion of those that contain the word boring. Indeed, to develop our family of tests, we will rely on a training set of already classified data from which we can determine estimates of probabilities that we need.</p>
</section>
<section id="an-example-dataset" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="an-example-dataset"><span class="header-section-number">4.2</span> An example dataset</h2>
<p>To illustrate the Naive Bayes algorithm, we will work with the “Sentiment Labelled Sentences Data Set” (<span class="citation" data-cites="sentences">[<a href="20-references.html#ref-sentences" role="doc-biblioref">1</a>]</span>). This dataset contains 3 files, each containing 1000 documents labelled <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span> for “negative” or “positive” sentiment. There are 500 of each type of document in each file. One file contains reviews of products from amazon.com; one contains yelp restaurant reviews, and one contains movie reviews from imdb.com.</p>
<p>Let’s focus on the amazon reviews data. Here are some samples:</p>
<pre><code>So there is no way for me to plug it in here 
    in the US unless I go by a converter.   0
Good case, Excellent value. 1
Great for the jawbone.  1
Tied to charger for conversations lasting more than 
    45 minutes.MAJOR PROBLEMS!! 0
The mic is great.   1
I have to jiggle the plug to get it to line up right to 
    get decent volume.  0
If you have several dozen or several hundred contacts, then 
    imagine the fun of sending each of them one by one. 0
If you are Razr owner...you must have this! 1
Needless to say, I wasted my money. 0
What a waste of money and time!.    0</code></pre>
<p>As you can see, each line consists of a product review followed by a <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>; in this file the review is separated from the text by a tab character.</p>
</section>
<section id="bernoulli-tests" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="bernoulli-tests"><span class="header-section-number">4.3</span> Bernoulli tests</h2>
<p>We will describe the “Bernoulli” version of a Naive Bayes classifier for this data. The building block of this method is a test based on a single word. For example, let’s consider the word <strong>great</strong> among all of our amazon reviews. It turns out that <strong>great</strong> occurs <span class="math inline">\(5\)</span> times in negative reviews and <span class="math inline">\(92\)</span> times in positive reviews among our <span class="math inline">\(1000\)</span> examples. So it seems that seeing the word <strong>great</strong> in a review makes it more likely to be positive. The appearances of great are summarized in <a href="#tbl-great">Table&nbsp;<span>4.1</span></a> . We write ~<strong>great</strong> for the case where <strong>great</strong> does <em>not</em> appear.</p>
<div id="tbl-great" class="anchored">
<table class="table">
<caption>Table&nbsp;4.1: Ocurrences of <strong>great</strong> by type of review</caption>
<thead>
<tr class="header">
<th></th>
<th>+</th>
<th>-</th>
<th>total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>great</strong></td>
<td>92</td>
<td>5</td>
<td>97</td>
</tr>
<tr class="even">
<td>~<strong>great</strong></td>
<td>408</td>
<td>495</td>
<td>903</td>
</tr>
<tr class="odd">
<td>total</td>
<td>500</td>
<td>500</td>
<td>1000</td>
</tr>
</tbody>
</table>
</div>
<p>In this data, positive and negative reviews are equally likely so <span class="math inline">\(P(+)=P(-)=.5\)</span> From this table, and Bayes Theorem, we obtain the empirical probabilities (or “naive” probabilities).</p>
<p><span class="math display">\[
P(\mathbf{great} | +) = \frac{92}{500} = .184
\]</span></p>
<p>and</p>
<p><span class="math display">\[
P(\mathbf{great}) = \frac{97}{1000} = .097
\]</span></p>
<p>Therefore</p>
<p><span class="math display">\[
P(+|\mathbf{great}) = \frac{.184}{.097}(.5) = 0.948.
\]</span></p>
<p>In other words, <em>if</em> you see the word <strong>great</strong> in a review, there’s a 95% chance that the review is positive.</p>
<p>What if you <em>do not</em> see the word <strong>great</strong>? A similar calculation from the table yields</p>
<p><span class="math display">\[
P(+|\sim\mathbf{great}) = \frac{408}{903} = .452
\]</span></p>
<p>In other words, <em>not</em> seeing the word great gives a little evidence that the review is negative (there’s a 55% chance it’s negative) but it’s not that conclusive.</p>
<p>The word <strong>waste</strong> is associated with negative reviews. It’s statistics are summarized in <a href="#tbl-waste">Table&nbsp;<span>4.2</span></a> .</p>
<div id="tbl-waste" class="anchored">
<table class="table">
<caption>Table&nbsp;4.2: Ocurrences of <strong>waste</strong> by type of review</caption>
<thead>
<tr class="header">
<th></th>
<th>+</th>
<th>-</th>
<th>total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>waste</strong></td>
<td>0</td>
<td>14</td>
<td>14</td>
</tr>
<tr class="even">
<td>~<strong>waste</strong></td>
<td>500</td>
<td>486</td>
<td>986</td>
</tr>
<tr class="odd">
<td>total</td>
<td>500</td>
<td>500</td>
<td>1000</td>
</tr>
</tbody>
</table>
</div>
<p>Based on this data, the “naive” probabilities we are interested in are:</p>
<p><span class="math display">\[\begin{align*}
P(+|\mathbf{waste}) &amp;= 0\\
P(+|\sim\mathbf{waste}) &amp;= .51
\end{align*}\]</span></p>
<p>In other words, if you see <strong>waste</strong> you definitely have a negative review, but if you don’t, you’re only slightly more likely to have a positive one.</p>
<p>What about combining these two tests? Or using even more words? We could analyze our data to count cases in which both <strong>great</strong> and <strong>waste</strong> occur, in which only one occurs, or in which neither occurs, within the two different categories of reviews, and then use those counts to estimate empirical probabilities of the joint events. But while this might be feasible with two words, if we want to use many words, the number of combinations quickly becomes huge. So instead, we make a basic, and probably false, assumption, but one that makes a simple analysis possible.</p>
<p><strong>Assumption:</strong> We assume that the presence or absence of the words <strong>great</strong> and <strong>waste</strong> in a particular review (positive or negative) are independent events. More generally, given a collection of words <span class="math inline">\(w_1,\ldots, w_k\)</span>, we assume that their occurences in a given review are independent events.</p>
<p>Independence means that we have <span class="math display">\[\begin{align*}
P(\mathbf{great},\mathbf{waste}|\pm) &amp;= P(\mathbf{great}|\pm)P(\mathbf{waste}|\pm)\\
P(\mathbf{great},\sim\mathbf{waste}|\pm) &amp;= P(\mathbf{great}|\pm)P(\sim\mathbf{waste}|\pm)\\
&amp;\vdots \\
\end{align*}\]</span></p>
<p>So for example, if a document contains the word <strong>great</strong> and does <em>not</em> contain the word <strong>waste</strong>, then the probability of it being a positive review is: <span class="math display">\[
P(+|\mathbf{great},\sim\mathbf{waste}) = \frac{P(\mathbf{great}|+)P(\sim\mathbf{waste}|+)P(+)}{P(\mathbf{great},\sim\mathbf{waste})}
\]</span> while the probability of it being a negative review is <span class="math display">\[
P(-|\mathbf{great},\sim\mathbf{waste}) = \frac{P(\mathbf{great}|-)P(\sim\mathbf{waste}|-)P(-)}{P(\mathbf{great},\sim\mathbf{waste})}
\]</span> Rather than compute these probabilities (which involves working out the denominators), let’s just compare them. Since they have the same denominators, we just need to compare numerators, which we call <span class="math inline">\(L\)</span> for likelihood: Using the data from <a href="#tbl-great">Table&nbsp;<span>4.1</span></a> and <a href="#tbl-waste">Table&nbsp;<span>4.2</span></a> , we obtain: <span class="math display">\[
L(+|\mathbf{great},\sim\mathbf{waste}) = (.184)(1)(.5) = .092
\]</span> and <span class="math display">\[
L(-|\mathbf{great},\sim\mathbf{waste}) = (.01)(.028)(.5) = .00014
\]</span> so our data suggests strongly that this is a positive review.</p>
</section>
<section id="feature-vectors" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="feature-vectors"><span class="header-section-number">4.4</span> Feature vectors</h2>
<p>To generalize this, suppose that we have extracted keywords <span class="math inline">\(w_1,\ldots, w_k\)</span> from our data and we have computed the empirical values <span class="math inline">\(P(w_{i}|+)\)</span> and <span class="math inline">\(P(w_{i}|-)\)</span> by counting the fraction of positive and negative reviews that contain the word <span class="math inline">\(w_{i}\)</span>:</p>
<p><span class="math display">\[
P(w_{i}|\pm) = \frac{\hbox{ number of $\pm$ reviews that mention $w_{i}$}}{\hbox{ number of $\pm$ reviews total}}
\]</span></p>
<p>Notice that we only count <em>reviews</em>, not <em>ocurrences</em>, so that if a word occurs multiple times in a review it only contributes 1 to the count. That’s why this is called the <em>Bernoulli</em> Naive Bayes – we are thinking of each keyword as yielding a yes/no test on each review.</p>
<p>Given a review, we look to see whether each of our <span class="math inline">\(k\)</span> keywords appears or does not. We encode this information as a vector of length <span class="math inline">\(k\)</span> containing <span class="math inline">\(0\)</span>’s and <span class="math inline">\(1\)</span>’s indicating the absence or presence of the <span class="math inline">\(k\)</span>th keyword. Let’s call this vector the <em>feature vector</em> for the review.</p>
<p>For example, if our keywords are <span class="math inline">\(w_1=\mathbf{waste}\)</span>, <span class="math inline">\(w_2=\mathbf{great}\)</span>, and <span class="math inline">\(w_3=\mathbf{useless}\)</span>, and our review says</p>
<pre><code>This phone is useless, useless, useless!  What a waste!</code></pre>
<p>then the associated feature vector is <span class="math inline">\(f=(1,0,1)\)</span>.</p>
<p>For the purposes of classification of our reviews, we are going to forget entirely about the text of our reviews and work only with the feature vectors. From an abstract perspective, then, by choosing our <span class="math inline">\(k\)</span> keywords, our “training set” of <span class="math inline">\(N\)</span> labelled reviews can be replaced by an <span class="math inline">\(N\times k\)</span> matrix <span class="math inline">\(X=(x_{ij})\)</span> with entries <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>, where <span class="math inline">\(x_{ij}=1\)</span> if and only if the <span class="math inline">\(j^{th}\)</span> keyword appears in the <span class="math inline">\(i^{th}\)</span> review.</p>
<p>The labels of <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span> for unfavorable or favorable reviews can also be packaged up into a <span class="math inline">\(N\times 1\)</span> vector <span class="math inline">\(Y\)</span> that serves as our “target” variable.</p>
<p>Setting things up this way lets us express the computations of our probabilities <span class="math inline">\(P(w_{i}|\pm)\)</span> in vector form. In fact, <span class="math inline">\(Y^{\intercal}X\)</span> is the sum of the rows of <span class="math inline">\(X\)</span> corresponding to positive reviews, and therefore, letting <span class="math inline">\(N_{\pm}\)</span> denote the number of <span class="math inline">\(\pm\)</span> reviews, <span class="math display">\[
P_{+} = \frac{1}{N_{+}}Y^{\intercal}X = \left[\begin{array}{cccc} P(w_{1}|+)&amp; P(w_{2}|+) &amp; \cdots &amp;P(w_{k}|+)\end{array}\right].
\]</span> Similarly, since <span class="math inline">\(Y\)</span> and <span class="math inline">\(X\)</span> have zero and one entries only, if we write <span class="math inline">\(1-Y\)</span> and <span class="math inline">\(1-X\)</span> for the matrices obtained by replacing every entry <span class="math inline">\(z\)</span> by <span class="math inline">\(1-z\)</span> in each matrix, we have: <span class="math display">\[
P_{-} = \frac{1}{N_{-}}(1-Y)^{\intercal}X =  \left[\begin{array}{cccc} P(w_{1}|-)&amp; P(w_{2}|-) &amp; \cdots &amp;P(w_{k}|-)\end{array}\right].
\]</span></p>
<p>Note that the number of positive reviews is <span class="math inline">\(N_{+}=Y^{\intercal}Y\)</span> and the number of negative ones is <span class="math inline">\(N_{-}=N-N_{+}\)</span>. Since <span class="math inline">\(P(+)\)</span> is the fraction of positive reviews among all reviews, we can compute it as <span class="math inline">\(P(+)=\frac{1}{N}Y^{\intercal}Y\)</span>, and <span class="math inline">\(P(-)=1-P(+)\)</span>.</p>
</section>
<section id="likelihood" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="likelihood"><span class="header-section-number">4.5</span> Likelihood</h2>
<p>If a review has an associated feature vector <span class="math inline">\(f=(f_1,\ldots, f_k)\)</span>, then by independence the probability of that feature vector ocurring within one of the <span class="math inline">\(\pm\)</span> classes is <span class="math display">\[
P(f|\pm) = \prod_{i: f_{i}=1} P(w_{i}|\pm)\prod_{i: f_{i}=0}(1-P(w_{i}|\pm))
\]</span> which we can also write <span id="eq-likelihood"><span class="math display">\[
P(f|\pm) = \prod_{i=1}^{k} P(w_{i}|\pm)^{f_{i}}(1-P(w_{i}|\pm))^{(1-f_{i})}.
\tag{4.1}\]</span></span></p>
<p>These products aren’t practical to work with – they are often the product of many, many small numbers and are therefore really tiny. Therefore it’s much more practical to work with their logarithms. <span id="eq-loglikelihood"><span class="math display">\[
\log P(f|\pm) = \sum_{i=1}^{k} f_{i}\log P(w_{i}|\pm) + (1-f_{i})\log(1-P(w_{i}|\pm))
\tag{4.2}\]</span></span></p>
<p>If we have a group of reviews <span class="math inline">\(N\)</span> organized in a matrix <span class="math inline">\(X\)</span>, where each row is the feature vector associated to the corresponding review, then we can compute all of this at once. We’ll write <span class="math inline">\(\log P_{\pm}=\log P(X|\pm)\)</span> as the row vector whose <span class="math inline">\(i^{th}\)</span> entry is <span class="math inline">\(\log P(f_{i}|\pm)\)</span>:</p>
<p><span id="eq-matrixlikelihood"><span class="math display">\[
\log P(X|\pm) = X(\log P_{\pm})^{\intercal}+(1-X)(\log (1-P_{\pm}))^{\intercal}.
\tag{4.3}\]</span></span></p>
<p>By Bayes Theorem, we can express the chance that our review with feature vector <span class="math inline">\(f\)</span> is positive or negative by the formula: <span class="math display">\[
\log P(\pm|f) = \log P(f|\pm)+\log P(\pm) - \log P(f)
\]</span> where <span class="math display">\[
P(\pm) = \frac{\hbox{ the number of $\pm$ reviews}}{\hbox{ total number of reviews}}
\]</span> and <span class="math inline">\(P(f)\)</span> is the fraction of reviews with the given feature vector. (Note: in practice, some of these probabilities will be zero, and so the log will not be defined. A common practical approach to dealing with this is to introduce a “fake document” into both classes in which every vocabulary word appears – this guarantees that the frequency matrix will have no zeros in it).</p>
<p>A natural classification rule would be to say that a review is positive if <span class="math inline">\(\log P(+|f)&gt;\log P(-|f)\)</span>, and negative otherwise. In applying this, we can avoid computing <span class="math inline">\(P(f)\)</span> by just comparing <span class="math inline">\(\log P(f|+)+\log P(+)\)</span> and <span class="math inline">\(\log P(f|-)+\log P(-)\)</span> computed using <a href="#eq-loglikelihood">Equation&nbsp;<span>4.2</span></a>. Then we say:</p>
<ul>
<li>a review is positive if <span class="math inline">\(\log P(f|+)+\log P(+)&gt;\log P(f|-)+\log P(-)\)</span> and negative otherwise.</li>
</ul>
<p>Again we can exploit the matrix structure to do this for a bunch of reviews at once. Using <a href="#eq-matrixlikelihood">Equation&nbsp;<span>4.3</span></a> and the vectors <span class="math inline">\(P_{\pm}\)</span> we can compute column vectors corresponding to both sides of our decision inequality and subtract them. The positive entries indicate positive reviews, and the negative ones, negative reviews.</p>
</section>
<section id="the-bag-of-words" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="the-bag-of-words"><span class="header-section-number">4.6</span> The Bag of Words</h2>
<p>In our analysis above, we thought of the presence or absence of certain key words as a set of independent tests that provided evidence of whether our review was positive or negative. This approach is suited to short pieces of text, but what about longer documents? In that case, we might want to consider not just the presence or absence of words, but the frequency with which they appear. Multinomial Naive Bayes, based on the “bag of words” model, is a classification method similar to Bernoulli Naive Bayes but which takes term frequency into account.</p>
<p>Let’s consider, as above, the problem of classifying documents into one of two classes. We assume that we have a set of keywords <span class="math inline">\(w_1,\ldots, w_k\)</span>. For each class <span class="math inline">\(\pm\)</span>, we have a set of probabilities <span class="math inline">\(P(w_i|\pm)\)</span> with the property that <span class="math display">\[
\sum_{i=1}^{k}P(w_{i}|\pm)=1.
\]</span></p>
<p>The “bag of words” model says that we construct a document of length <span class="math inline">\(N\)</span> in, say, the <span class="math inline">\(+\)</span> class by independently drawing a word <span class="math inline">\(N\)</span> times from the set <span class="math inline">\(w_1,\ldots, w_k\)</span> with probabilities <span class="math inline">\(P(w_{i}|+)\)</span>. The name “bag of words” comes from thinking of each class as having an associated bag containing the words <span class="math inline">\(w_1,\ldots, w_k\)</span> with relative frequencies given by the probabilities, and generating a document by repeatedly drawing a word from the bag.</p>
<p>In the Multinomial Naive Bayes method, we estimate the probabilities <span class="math inline">\(P(w_{i}|\pm)\)</span> by counting the number of times each word occurs in a document of the given class: <span class="math display">\[
P(w_{i}|\pm) = \frac{\hbox{ number of times word $i$ occurs in $\pm$ documents}}{\hbox{ total number of words in $\pm$ documents}}
\]</span> This is the “naive” part of the algorithm. Package up these probabilities in vectors: <span class="math display">\[
P_{\pm} = \left[\begin{array}{ccc} P(w_{1}|\pm) &amp; \cdots &amp; P(w_{k}|\pm)\end{array}\right].
\]</span></p>
<p>As in the Bernoulli case, we often add a fake document to each class where all of the words occur once, in order to avoid having zero frequencies when we take a logarithm later.</p>
<p>Now, given a document, we associate a feature vector <span class="math inline">\(\mathbf{f}\)</span> whose <span class="math inline">\(i^{th}\)</span> entry is the frequency with which word <span class="math inline">\(i\)</span> appears in that document. The probability of obtaining a particular document with feature vector <span class="math inline">\(\mathbf{f}=(f_1,\ldots, f_k)\)</span> from the bag of words associated with class <span class="math inline">\(\pm\)</span> is given by the “multinomial” distribution: <span class="math display">\[
P(\mathbf{f}|\pm)=\frac{N!}{f_1!f_2!\cdots f_k!} \prod_{i=1}^{k} P(w_{i}|\pm)^{f_{i}}
\]</span> which generalizes the binomial distribution to multiple choices. The constant will prove irrelevant, so let’s call the interesting part <span class="math inline">\(L_{\pm}\)</span>: <span class="math display">\[
L(\mathbf{f}|\pm)= \prod_{i=1}^{k} P(w_{i}|\pm)^{f_{i}}
\]</span></p>
<p>From Bayes Theorem, we have <span class="math display">\[
P(\pm|\mathbf{f}) = \frac{P(\mathbf{f}|\pm)P(\pm)}{P(\mathbf{f})}
\]</span> where <span class="math inline">\(P(\pm)\)</span> is estimated by the fraction of documents (total) in each class.</p>
<p>We classify our document by considering <span class="math inline">\(P(\pm|\mathbf{f})\)</span> and concluding:</p>
<ul>
<li>a document with feature vector <span class="math inline">\(\mathbf{f}\)</span> is in class <span class="math inline">\(+\)</span> if <span class="math inline">\(\log P(+|\mathbf{f})&gt;\log P(-|\mathbf{f})\)</span>.</li>
</ul>
<p>In this comparison, both the constant (the multinomial coefficient) and the denominator cancel out, so we only need to compare <span class="math inline">\(\log L(\mathbf{f}|+)+\log P(+)\)</span> with <span class="math inline">\(\log L(\mathbf{f}|-)+\log P(-)\)</span> We have <span class="math display">\[
\log L(\mathbf{f}|\pm) = \sum_{i=1}^{k} f_{i}\log P(w_{i}|\pm)
\]</span> or, in vector form, <span class="math display">\[
\log P(\mathbf{f}|\pm) = \mathbf{f}\log P_{\pm}^{\intercal}
\]</span></p>
<p>Therefore, just as in the Bernoulli case, we can package up our document <span class="math inline">\(i\)</span> as an <span class="math inline">\(N\times k\)</span> data matrix <span class="math inline">\(X\)</span>, where position <span class="math inline">\(ij\)</span> gives the number of times word <span class="math inline">\(j\)</span> occurs in document <span class="math inline">\(i\)</span>. Then we can compute the vector <span class="math display">\[
\hat{Y} = X\log P_{+}^{\intercal} + \log P(+)-X\log P_{-}^{\intercal} - \log P(-)
\]</span> and assign those documents where <span class="math inline">\(\hat{Y}&gt;0\)</span> to the <span class="math inline">\(+\)</span> class and the rest to the <span class="math inline">\(-\)</span> class.</p>
</section>
<section id="other-applications" class="level2" data-number="4.7">
<h2 data-number="4.7" class="anchored" data-anchor-id="other-applications"><span class="header-section-number">4.7</span> Other applications</h2>
<p>We developed the Naive Bayes method for sentiment analysis, but once we chose a set of keywords our training data was reduced to an <span class="math inline">\(N\times k\)</span> matrix <span class="math inline">\(X\)</span> of <span class="math inline">\(0/1\)</span> entries, together with an <span class="math inline">\(N\times 1\)</span> target column vector <span class="math inline">\(Y\)</span>. Then our classification problem is to decide whether a given vector of <span class="math inline">\(k\)</span> entries, all <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>, is more likely to carry a <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span> label. All of the parameters we needed for Naive Bayes – the various probabilities – can be extracted from the matrix <span class="math inline">\(X\)</span>.</p>
<p>For example, suppose we have a collection of images represented as black/white pixels in a grid that belong to one of two classes. For example, we might have <span class="math inline">\(28x28\)</span> bitmaps of handwritten zeros and ones that are labelled, and we wish to construct a classifier that can decide whether a new <span class="math inline">\(28x28\)</span> bitmap is a zero or one. An example of such a bitmap is given in <a href="#fig-mnist0">Figure&nbsp;<span>4.1</span></a>. We can view each <span class="math inline">\(28x28\)</span> bitmap as a vector of length <span class="math inline">\(784\)</span> with <span class="math inline">\(0/1\)</span> entries and apply the same approach outlined above. However, there are other methods that are more commonly used for this problem, such as logistic regression and neural networks.</p>
<div id="fig-mnist0" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="img/mnist_data_10_0.png" class="img-fluid figure-img" style="width:2in"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;4.1: Handwritten 0</figcaption><p></p>
</figure>
</div>


<div id="refs" class="references csl-bib-body" role="doc-bibliography" style="display: none">
<div id="ref-sentences" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline"><span class="smallcaps">U.C. Irvine ML Repository</span>. <span>Sentiment Labelled Sentences Data Set</span>.Available at <a href="https://archive.ics.uci.edu/ml/datasets/Sentiment+Labelled+Sentences">https://archive.ics.uci.edu/ml/datasets/Sentiment+Labelled+Sentences</a>.</div>
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../chapters/03-probability.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Probability and Bayes Theorem</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../chapters/05-1-gradient-descent.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Gradient Descent</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">© 2021. This work is licensed by Jeremy Teitelbaum under the <a href="http://creativecommons.org/licenses/by-sa/4.0">Creative Commons Attribution-ShareAlike License</a>.</div>
  </div>
</footer>



</body></html>